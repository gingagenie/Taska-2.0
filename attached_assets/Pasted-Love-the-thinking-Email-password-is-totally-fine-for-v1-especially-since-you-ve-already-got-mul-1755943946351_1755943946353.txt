Love the thinking. Email + password is totally fine for v1 — especially since you’ve already got multi-tenant isolation baked in. Keep it simple now, add “magic links / SSO” later if you want. Below is a Replit-ready script that will:

create orgs + users on signup

let users log in with email + password

store sessions (no more header hacks)

keep your multi-tenant model solid (org_id everywhere)

add a simple landing page + /auth/register + /auth/login screens


Paste this to Replit and let it run.


---

Replit Agent — Add Orgs + Email/Password Auth + Landing Page

0) Add deps (hashing)

package.json → dependencies: add

"bcryptjs": "^2.4.3"

Install packages.


---

1) DB migration (idempotent)

Create: server/db/migrations/2025_auth_orgs.sql

-- orgs
create table if not exists orgs (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  created_at timestamptz not null default now()
);

-- users (extend if exists)
alter table users
  add column if not exists org_id uuid,
  add column if not exists email text,
  add column if not exists password_hash text,
  add column if not exists role text,
  add column if not exists phone text,
  add column if not exists avatar_url text,
  add column if not exists avatar_seed text,
  add column if not exists avatar_variant text,
  add column if not exists email_verified_at timestamptz,
  add column if not exists created_at timestamptz default now(),
  add column if not exists last_login_at timestamptz;

-- membership unique per org
create unique index if not exists users_org_email_unique
  on users (org_id, lower(email));

create index if not exists users_org_idx on users(org_id);

(Your existing data stays put; new columns just appear.)


---

2) Sessions (if not already set)

Edit: server/index.ts (or wherever you create the Express app) — add session middleware before routes:

import session from "express-session";
import pgSession from "connect-pg-simple";
import { Pool } from "pg";

const PgStore = pgSession(session as any);
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

app.use(
  session({
    store: new PgStore({ pool, tableName: "session" }),
    secret: process.env.SESSION_SECRET || "dev-secret-change-me",
    resave: false,
    saveUninitialized: false,
    cookie: {
      sameSite: "lax",
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 24 * 30, // 30 days
    },
  })
);

Create the session table once (connect-pg-simple DDL):

CREATE TABLE IF NOT EXISTS "session" (
  "sid" varchar NOT NULL COLLATE "default",
  "sess" json NOT NULL,
  "expire" timestamp(6) NOT NULL
)
WITH (OIDS=FALSE);

ALTER TABLE "session" ADD CONSTRAINT "session_pkey" PRIMARY KEY ("sid");
CREATE INDEX IF NOT EXISTS "IDX_session_expire" ON "session" ("expire");

(You can drop that in a migration file if you like.)


---

3) Auth routes (register/login/logout)

Create: server/routes/auth.ts

import { Router } from "express";
import { db } from "../db/client";
import { sql } from "drizzle-orm";
import bcrypt from "bcryptjs";

const router = Router();

router.post("/register", async (req, res) => {
  const { orgName, name, email, password } = req.body || {};
  if (!orgName || !email || !password) return res.status(400).json({ error: "orgName, email, password required" });

  const orgIns: any = await db.execute(sql`
    insert into orgs (name) values (${orgName}) returning id
  `);
  const orgId = orgIns.rows[0].id;

  const hash = await bcrypt.hash(password, 10);
  const userIns: any = await db.execute(sql`
    insert into users (org_id, name, email, password_hash, role)
    values (${orgId}::uuid, ${name||'Owner'}, ${email}, ${hash}, 'admin')
    returning id, name, email, role
  `);
  const user = userIns.rows[0];

  (req.session as any).userId = user.id;
  (req.session as any).orgId = orgId;

  res.json({ ok: true, orgId, user });
});

router.post("/login", async (req, res) => {
  const { email, password, orgId } = req.body || {};
  if (!email || !password) return res.status(400).json({ error: "email & password required" });

  // If orgId not provided, pick first match by email (single-org assumption for now)
  const r: any = await db.execute(sql`
    select id, org_id, email, password_hash, name, role
    from users
    where lower(email)=lower(${email})
    ${orgId ? sql`and org_id=${orgId}::uuid` : sql``}
    order by created_at asc
    limit 1
  `);
  const user = r.rows?.[0];
  if (!user) return res.status(401).json({ error: "Invalid credentials" });

  const ok = await bcrypt.compare(password, user.password_hash || "");
  if (!ok) return res.status(401).json({ error: "Invalid credentials" });

  await db.execute(sql`update users set last_login_at=now() where id=${user.id}::uuid`);

  (req.session as any).userId = user.id;
  (req.session as any).orgId = user.org_id;

  res.json({ ok: true, orgId: user.org_id, user: { id: user.id, name: user.name, email: user.email, role: user.role } });
});

router.post("/logout", (req, res) => {
  req.session.destroy(() => res.json({ ok: true }));
});

export default router;

Mount it in your server bootstrap:

import auth from "./routes/auth";
app.use("/api/auth", auth);


---

4) Make your auth middleware session-aware

Edit: server/middleware/auth.ts

import { Request, Response, NextFunction } from "express";

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  // support dev headers
  const hUser = req.headers["x-user-id"] as string | undefined;
  if (hUser) {
    (req as any).user = { id: hUser };
    return next();
  }
  const userId = (req.session as any)?.userId;
  if (!userId) return res.status(401).json({ error: "Not authenticated" });
  (req as any).user = { id: userId };
  next();
}

Edit: server/middleware/tenancy.ts

import { Request, Response, NextFunction } from "express";

export function requireOrg(req: Request, res: Response, next: NextFunction) {
  const hOrg = req.headers["x-org-id"] as string | undefined;
  if (hOrg) { (req as any).orgId = hOrg; return next(); }
  const orgId = (req.session as any)?.orgId;
  if (!orgId) return res.status(400).json({ error: "No organization selected" });
  (req as any).orgId = orgId;
  next();
}

(So your API works via session by default; still supports headers for dev.)


---

5) Landing + Auth pages (client)

A) Add a simple marketing landing Create: client/src/pages/landing.tsx

import { Link } from "wouter";
import { Button } from "@/components/ui/button";

export default function Landing() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-white to-gray-50">
      <header className="max-w-5xl mx-auto px-6 py-6 flex items-center justify-between">
        <div className="text-xl font-bold">Taska</div>
        <div className="flex gap-3">
          <Link href="/auth/login"><a><Button variant="ghost">Log in</Button></a></Link>
          <Link href="/auth/register"><a><Button>Get Started</Button></a></Link>
        </div>
      </header>
      <main className="max-w-5xl mx-auto px-6 py-16 grid md:grid-cols-2 gap-10 items-center">
        <div>
          <h1 className="text-4xl font-extrabold leading-tight">Field service, simplified.</h1>
          <p className="mt-4 text-gray-600">Jobs, customers, equipment, invoices—everything in one fast app.</p>
          <div className="mt-6 flex gap-3">
            <Link href="/auth/register"><a><Button>Start free</Button></a></Link>
            <Link href="/auth/login"><a><Button variant="outline">Log in</Button></a></Link>
          </div>
        </div>
        <div className="rounded-xl border bg-white h-72 shadow-sm flex items-center justify-center text-gray-400">
          App preview
        </div>
      </main>
    </div>
  );
}

B) Register Create: client/src/pages/auth-register.tsx

import { useState } from "react";
import { useLocation, Link } from "wouter";
import { api } from "@/lib/api";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export default function Register() {
  const [, nav] = useLocation();
  const [orgName, setOrgName] = useState("");
  const [name, setName] = useState("");
  const [email,setEmail] = useState("");
  const [password,setPassword] = useState("");
  const [err,setErr] = useState<string|null>(null);
  const [saving,setSaving] = useState(false);

  async function submit() {
    setSaving(true); setErr(null);
    try {
      await api("/api/auth/register", { method:"POST", body: JSON.stringify({ orgName, name, email, password }) });
      nav("/"); // now logged in via session
    } catch(e:any){ setErr(e.message || "Failed"); } finally { setSaving(false); }
  }

  return (
    <div className="min-h-screen flex items-center justify-center p-6">
      <Card className="w-full max-w-md">
        <CardHeader><CardTitle>Create your account</CardTitle></CardHeader>
        <CardContent className="space-y-4">
          {err && <div className="text-red-600 text-sm">{err}</div>}
          <Input placeholder="Business name" value={orgName} onChange={e=>setOrgName(e.target.value)} />
          <Input placeholder="Your name" value={name} onChange={e=>setName(e.target.value)} />
          <Input type="email" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
          <Input type="password" placeholder="Password" value={password} onChange={e=>setPassword(e.target.value)} />
          <Button className="w-full" onClick={submit} disabled={saving}>{saving?"Creating…":"Create account"}</Button>
          <div className="text-center text-sm text-gray-600">Already have an account? <Link href="/auth/login"><a className="text-blue-600">Log in</a></Link></div>
        </CardContent>
      </Card>
    </div>
  );
}

C) Login Create: client/src/pages/auth-login.tsx

import { useState } from "react";
import { useLocation, Link } from "wouter";
import { api } from "@/lib/api";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export default function Login() {
  const [, nav] = useLocation();
  const [email,setEmail] = useState("");
  const [password,setPassword] = useState("");
  const [err,setErr] = useState<string|null>(null);
  const [saving,setSaving] = useState(false);

  async function submit() {
    setSaving(true); setErr(null);
    try {
      await api("/api/auth/login", { method:"POST", body: JSON.stringify({ email, password }) });
      nav("/");
    } catch(e:any){ setErr(e.message || "Failed"); } finally { setSaving(false); }
  }

  return (
    <div className="min-h-screen flex items-center justify-center p-6">
      <Card className="w-full max-w-md">
        <CardHeader><CardTitle>Log in</CardTitle></CardHeader>
        <CardContent className="space-y-4">
          {err && <div className="text-red-600 text-sm">{err}</div>}
          <Input type="email" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
          <Input type="password" placeholder="Password" value={password} onChange={e=>setPassword(e.target.value)} />
          <Button className="w-full" onClick={submit} disabled={saving}>{saving?"Signing in…":"Log in"}</Button>
          <div className="text-center text-sm text-gray-600">No account? <Link href="/auth/register"><a className="text-blue-600">Create one</a></Link></div>
        </CardContent>
      </Card>
    </div>
  );
}

D) Routes Edit: client/src/App.tsx

import Landing from "@/pages/landing";
import Register from "@/pages/auth-register";
import Login from "@/pages/auth-login";

// Public routes
<Route path="/auth/register" component={Register} />
<Route path="/auth/login" component={Login} />

// If you want Taska.info (marketing) to show landing:
// make "/" go to Landing if not authenticated; else Dashboard.
// Example pattern:
import { useAuth } from "@/hooks/use-auth";
function Root() {
  const { user } = useAuth(); // fetches /api/me
  return user ? <Dashboard /> : <Landing />;
}
<Route path="/" component={Root} />

(If you prefer a separate marketing domain later, we can split.)


---

6) Members: simple create-with-password (optional)

On your Add Member modal, add an optional password field:

If provided → set initial password (hash on server) and they can log in immediately.

If empty now → you can add a “Send invite” later when email is wired.


Server tweak (members route)

import bcrypt from "bcryptjs";
// ...
const { email, name, role, phone, initialPassword } = req.body || {};
const hash = initialPassword ? await bcrypt.hash(initialPassword, 10) : null;
const ins: any = await db.execute(sql`
  insert into users (org_id, email, name, role, phone, password_hash)
  values (${orgId}::uuid, ${email}, ${name||null}, ${roleNorm}, ${phone||null}, ${hash})
  on conflict (org_id, lower(email)) do update
  set name=excluded.name, role=excluded.role, phone=excluded.phone
  returning id, email, name, role, phone, created_at
`);


---

7) Domain (Taska.info)

On Replit Pro you can map a custom domain:

Point taska.info (root or www) to your Replit app.

The landing page will show for non-authed users (as above).

Your Android/iOS apps can continue to call the same backend URL.



---

Why email+password is a good call now

Dead simple for you and your customers.

Works great with your Add Member UI.

Later you can add: email verification, password reset, magic links, Google/Microsoft SSO — without breaking this.


If you want, I can also add /auth/password-reset endpoints + a minimal “reset via code” UI (no email provider required yet), but this gets you org creation + login today.

